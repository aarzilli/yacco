diff --git a/events.go b/events.go
index 1af1cb2..fd5dd6b 100644
--- a/events.go
+++ b/events.go
@@ -45,6 +45,7 @@ type MouseMovedEvent struct {
 type MouseButtonEvent struct {
 	MouseEvent
 	Which Button
+	Modifiers string
 }
 
 type MouseDownEvent MouseButtonEvent
@@ -53,6 +54,7 @@ type MouseUpEvent MouseButtonEvent
 type MouseDraggedEvent struct {
 	MouseMovedEvent
 	Which Button
+	Modifiers string
 }
 
 type MouseEnteredEvent MouseMovedEvent
diff --git a/keys.go b/keys.go
index 897f1f6..82d1c57 100644
--- a/keys.go
+++ b/keys.go
@@ -164,10 +164,10 @@ func (c ChordSorter) Less(i, j int) (less bool) {
 func ConstructChord(keys map[string]bool) (chord string) {
 	unikeys := map[string]bool{}
 	for key := range keys {
-		if strings.HasPrefix(key, "left_") {
+		if strings.HasPrefix(key, "left_") && (key != "left_arrow"){
 			key = key[5:]
 		}
-		if strings.HasPrefix(key, "right_") {
+		if strings.HasPrefix(key, "right_") && (key != "right_arrow") {
 			key = key[6:]
 		}
 		unikeys[key] = true
diff --git a/wde.go b/wde.go
index fbb6aed..22847cb 100644
--- a/wde.go
+++ b/wde.go
@@ -31,6 +31,14 @@ type Window interface {
 	FlushImage(bounds ...image.Rectangle)
 	EventChan() (events <-chan interface{})
 	Close() (err error)
+	ChangeCursor(n DefaultCursor)
+	WarpMouse(p image.Point)
+	NewTemp(p image.Point, width, height int) (Window, error)
+	SetClipboard(text string)
+	GetClipboard() string
+	GetPrimarySelection() string
+	Move(p image.Point, width, height int) error
+	Hide()
 }
 
 type Image interface {
@@ -40,11 +48,26 @@ type Image interface {
 	CopyRGBA(src *image.RGBA, bounds image.Rectangle)
 }
 
+type DefaultCursor int
+const (
+	BottomLeftCornerCursor DefaultCursor = iota
+	BottomRightCornerCursor
+	BottomSideCursor
+	FleurCursor
+	Hand1Cursor
+	TopLeftArrowCursor
+	TopLeftCornerCursor
+	TopRightCornerCursor
+	TopSideCursor
+	XTermCursor
+	LastCursor
+)
+
 /*
  */
 
 /*
-Some wde backends (cocoa) require that this function be called in the 
+Some wde backends (cocoa) require that this function be called in the
 main thread. To make your code as cross-platform as possible, it is
 recommended that your main function look like the the code below.
 
diff --git a/xgb/events.go b/xgb/events.go
index 5a66a25..3906b6d 100644
--- a/xgb/events.go
+++ b/xgb/events.go
@@ -18,13 +18,15 @@ package xgb
 
 import (
 	"fmt"
+	"image"
+	"strings"
 	"github.com/BurntSushi/xgb/xproto"
+//	"github.com/BurntSushi/xgbutil/xprop"
 	"github.com/BurntSushi/xgbutil/icccm"
 	"github.com/BurntSushi/xgbutil/keybind"
 	"github.com/BurntSushi/xgbutil/xevent"
 	"github.com/BurntSushi/xgbutil/xgraphics"
 	"github.com/skelterjohn/go.wde"
-	"image"
 )
 
 func buttonForDetail(detail xproto.Button) wde.Button {
@@ -43,6 +45,24 @@ func buttonForDetail(detail xproto.Button) wde.Button {
 	return 0
 }
 
+func xlibChord(k string, state uint16) string {
+	r := []string{}
+	if (state & xproto.ModMaskControl) != 0 {
+		r = append(r, "control")
+	}
+	if (state & xproto.ModMask1) != 0 {
+		r = append(r, "alt")
+	}
+	if (state & xproto.ModMaskShift) != 0 {
+		r = append(r, "shift")
+	}
+	if (state & xproto.ModMask4) != 0 {
+		r = append(r, "super")
+	}
+	r = append(r, k)
+	return strings.Join(r, "+")
+}
+
 func (w *Window) handleEvents() {
 	var noX int32 = 1<<31 - 1
 	noX++
@@ -55,7 +75,7 @@ func (w *Window) handleEvents() {
 		e, err := w.conn.WaitForEvent()
 
 		if err != nil {
-			fmt.Println("[go.wde X error] ", err)
+			//fmt.Println("[go.wde X error] ", err)
 			continue
 		}
 
@@ -69,6 +89,7 @@ func (w *Window) handleEvents() {
 			bpe.Where.Y = int(e.EventY)
 			lastX = int32(e.EventX)
 			lastY = int32(e.EventY)
+			bpe.Modifiers = xlibChord("", e.State)
 			w.events <- bpe
 
 		case xproto.ButtonReleaseEvent:
@@ -79,6 +100,7 @@ func (w *Window) handleEvents() {
 			bue.Where.Y = int(e.EventY)
 			lastX = int32(e.EventX)
 			lastY = int32(e.EventY)
+			bue.Modifiers = xlibChord("", e.State)
 			w.events <- bue
 
 		case xproto.LeaveNotifyEvent:
@@ -95,6 +117,7 @@ func (w *Window) handleEvents() {
 			lastX = int32(e.EventX)
 			lastY = int32(e.EventY)
 			w.events <- wee
+			downKeys = map[string]bool{}
 		case xproto.EnterNotifyEvent:
 			var wee wde.MouseEnteredEvent
 			wee.Where.X = int(e.EventX)
@@ -129,6 +152,7 @@ func (w *Window) handleEvents() {
 				var mde wde.MouseDraggedEvent
 				mde.MouseMovedEvent = mme
 				mde.Which = button
+				mde.Modifiers = xlibChord("", e.State)
 				w.events <- mde
 			}
 
@@ -141,7 +165,7 @@ func (w *Window) handleEvents() {
 			kpe := wde.KeyTypedEvent{
 				KeyEvent: ke,
 				Glyph:    letterForCode(code),
-				Chord:    wde.ConstructChord(downKeys),
+				Chord:    xlibChord(ke.Key, e.State),
 			}
 			w.events <- kpe
 
@@ -176,6 +200,47 @@ func (w *Window) handleEvents() {
 		case xproto.UnmapNotifyEvent:
 		case xproto.PropertyNotifyEvent:
 
+		case xproto.SelectionRequestEvent:
+			//tgtname, _ := xprop.AtomName(w.xu, e.Target)
+			//fmt.Println("SelectionRequest", e, textAtom, tgtname)
+
+			if e.Target != textAtom {
+				//println("Skipping")
+				sn := xproto.SelectionNotifyEvent{
+					Time: xproto.TimeCurrentTime,
+					Requestor: e.Requestor,
+					Selection: clipboardAtom,
+					Target: textAtom,
+					Property: 0, }
+				sec := xproto.SendEventChecked(w.conn, false, e.Requestor, 0, string(sn.Bytes()))
+				err := sec.Check()
+				if err != nil {
+					fmt.Println(err)
+				}
+				break
+			}
+
+			cpc := xproto.ChangePropertyChecked(w.conn, xproto.PropModeReplace, e.Requestor, e.Property, textAtom, 8, uint32(len(selectionText)), []byte(selectionText))
+			err := cpc.Check()
+			if err == nil {
+				sn := xproto.SelectionNotifyEvent{
+					Time: xproto.TimeCurrentTime,
+					Requestor: e.Requestor,
+					Selection: clipboardAtom,
+					Target: textAtom,
+					Property: e.Property, }
+				sec := xproto.SendEventChecked(w.conn, false, e.Requestor, 0, string(sn.Bytes()))
+				err = sec.Check()
+				if err != nil {
+					fmt.Println(err)
+				}
+			} else {
+				fmt.Println(err)
+			}
+
+		case xproto.SelectionNotifyEvent:
+			w.selnotify <- (e.Property == clipboardAtom) || (e.Property == primaryAtom)
+
 		default:
 			fmt.Printf("unhandled event: type %T\n%+v\n", e, e)
 		}
diff --git a/xgb/xgb.go b/xgb/xgb.go
index 08cc732..ee5a260 100644
--- a/xgb/xgb.go
+++ b/xgb/xgb.go
@@ -18,19 +18,39 @@ package xgb
 
 import (
 	"fmt"
+	"time"
 	"github.com/BurntSushi/xgb"
+//	"github.com/BurntSushi/xgbutil/xprop"
 	"github.com/BurntSushi/xgb/xproto"
 	"github.com/BurntSushi/xgbutil"
 	"github.com/BurntSushi/xgbutil/ewmh"
 	"github.com/BurntSushi/xgbutil/icccm"
 	"github.com/BurntSushi/xgbutil/keybind"
+	"github.com/BurntSushi/xgbutil/xcursor"
 	"github.com/BurntSushi/xgbutil/xgraphics"
 	"github.com/BurntSushi/xgbutil/xwindow"
+	"github.com/BurntSushi/xgbutil/motif"
 	"github.com/skelterjohn/go.wde"
 	"image"
 	"sync"
 )
 
+var defaultCursorToX = map[wde.DefaultCursor]uint16{
+	wde.BottomLeftCornerCursor: xcursor.BottomLeftCorner,
+	wde.BottomRightCornerCursor: xcursor.BottomRightCorner,
+	wde.BottomSideCursor: xcursor.BottomSide,
+	wde.FleurCursor: xcursor.Fleur,
+	wde.Hand1Cursor: xcursor.Hand1,
+	wde.TopLeftCornerCursor: xcursor.TopLeftCorner,
+	wde.TopRightCornerCursor: xcursor.TopRightCorner,
+	wde.TopSideCursor: xcursor.TopSide,
+	wde.XTermCursor: xcursor.XTerm,
+}
+
+var selectionText string
+var clipboardAtom, primaryAtom, textAtom xproto.Atom
+var cursors = []xproto.Cursor{}
+
 func init() {
 	wde.BackendNewWindow = func(width, height int) (w wde.Window, err error) {
 		w, err = NewWindow(width, height)
@@ -43,6 +63,23 @@ func init() {
 	wde.BackendStop = func() {
 		ch <- struct{}{}
 	}
+
+	X, err := xgbutil.NewConn()
+	if err != nil {
+		panic(err)
+	}
+
+	cursors = make([]xproto.Cursor, wde.LastCursor)
+	for i, v := range defaultCursorToX {
+		cursors[i], err = xcursor.CreateCursor(X, v)
+		if err != nil {
+			panic(err)
+		}
+	}
+
+	clipboardAtom = internAtom(X.Conn(), "CLIPBOARD")
+	primaryAtom = internAtom(X.Conn(), "PRIMARY")
+	textAtom = internAtom(X.Conn(), "UTF8_STRING")
 }
 
 const AllEventsMask = xproto.EventMaskKeyPress |
@@ -53,9 +90,13 @@ const AllEventsMask = xproto.EventMaskKeyPress |
 	xproto.EventMaskLeaveWindow |
 	xproto.EventMaskPointerMotion |
 	xproto.EventMaskStructureNotify
+	
+const TempEventsMask = xproto.EventMaskStructureNotify
+	
 
 type Window struct {
 	win           *xwindow.Window
+	parent        *Window
 	xu            *xgbutil.XUtil
 	conn          *xgb.Conn
 	buffer        *xgraphics.Image
@@ -65,12 +106,14 @@ type Window struct {
 	closed        bool
 
 	events chan interface{}
+	selnotify chan bool
 }
 
 func NewWindow(width, height int) (w *Window, err error) {
 
 	w = new(Window)
 	w.width, w.height = width, height
+	w.selnotify = make(chan bool, 1)
 
 	w.xu, err = xgbutil.NewConn()
 	if err != nil {
@@ -116,6 +159,80 @@ func NewWindow(width, height int) (w *Window, err error) {
 	return
 }
 
+func (w *Window) Move(p image.Point, width, height int) (err error) {
+	w.win.Move(p.X, p.Y)
+	w.win.Resize(width, height)
+	return nil
+}
+
+func (pw *Window) NewTemp(p image.Point, width, height int) (wr wde.Window, err error) {
+	w := new(Window)
+	w.parent = pw
+	w.width, w.height = width, height
+	w.selnotify = make(chan bool, 1)
+
+	w.xu, err = xgbutil.NewConn()
+	if err != nil {
+		return
+	}
+
+	w.conn = w.xu.Conn()
+
+	w.win, err = xwindow.Generate(w.xu)
+	if err != nil {
+		return
+	}
+
+	/*tp, err := pw.translateToScreen(p)
+	if err != nil {
+		println("Err translating to screen")
+		return
+	}*/
+
+	err = w.win.CreateChecked(pw.win.Id, p.X, p.Y, width, height, xproto.CwSaveUnder|xproto.CwOverrideRedirect, 1, 1)
+	//err = w.win.CreateChecked(w.xu.Screen().Root, tp.X, tp.Y, width, height, 0)
+	if err != nil {
+		println("Err creating window")
+		return
+	}
+
+	var mh motif.Hints
+	mh.Flags = motif.HintFunctions | motif.HintDecorations | motif.HintInputMode
+	mh.Function = motif.FunctionNone
+	mh.Decoration = motif.DecorationNone
+	mh.Input = motif.InputModeless
+	err = motif.WmHintsSet(w.xu, w.win.Id, &mh)
+	if err != nil {
+		println("Error setting hints")
+		return
+	}
+
+	w.win.Listen(TempEventsMask)
+
+	err = icccm.WmProtocolsSet(w.xu, w.win.Id, []string{"WM_DELETE_WINDOW"})
+	if err != nil {
+		fmt.Println(err)
+		err = nil
+	}
+
+	w.bufferLck = &sync.Mutex{}
+	w.buffer = xgraphics.New(w.xu, image.Rect(0, 0, width, height))
+	w.buffer.XSurfaceSet(w.win.Id)
+
+	keyMap, modMap := keybind.MapsGet(w.xu)
+	keybind.KeyMapSet(w.xu, keyMap)
+	keybind.ModMapSet(w.xu, modMap)
+
+	w.events = make(chan interface{})
+
+	go w.handleEvents()
+
+	wr = w
+
+	return
+}
+
+
 func (w *Window) SetTitle(title string) {
 	if w.closed {
 		return
@@ -172,6 +289,13 @@ func (w *Window) Show() {
 	w.win.Map()
 }
 
+func (w *Window) Hide() {
+	if w.closed {
+		return
+	}
+	w.win.Unmap()
+}
+
 func (w *Window) Screen() (im wde.Image) {
 	if w.closed {
 		return
@@ -239,3 +363,97 @@ func (buffer Image) CopyRGBA(src *image.RGBA, r image.Rectangle) {
 		}
 	}
 }
+
+func (w *Window) ChangeCursor(n wde.DefaultCursor) {
+	if n < 0 {
+		w.win.Change(xproto.CwCursor, 0)
+	} else {
+		w.win.Change(xproto.CwCursor, uint32(cursors[n]))
+	}
+}
+
+func (w *Window) translateToScreen(p image.Point) (r image.Point, err error) {
+	screen := w.xu.Screen()
+	tcc := xproto.TranslateCoordinates(w.conn, w.win.Id, screen.Root, int16(p.X), int16(p.Y))
+	tcr, err := tcc.Reply()
+	if err != nil {
+		return
+	}
+	r.X = int(tcr.DstX)
+	r.Y = int(tcr.DstY)
+	return
+}
+
+func (w *Window) WarpMouse(p image.Point) {
+	screen := w.xu.Screen()
+	tp, err := w.translateToScreen(p)
+	if err != nil {
+		fmt.Println(err)
+		return
+	}
+	wpc := xproto.WarpPointerChecked(w.conn, 0, screen.Root, 0, 0, 0, 0, int16(tp.X), int16(tp.Y))
+	err = wpc.Check()
+	if err != nil {
+		fmt.Println(err)
+		return
+	}
+}
+
+func internAtom(conn *xgb.Conn, n string) xproto.Atom {
+	iac := xproto.InternAtom(conn, true, uint16(len(n)), n)
+	iar, err := iac.Reply()
+	if err != nil {
+		fmt.Println(err)
+		return 0
+	}
+	return iar.Atom
+}
+
+func (w *Window) SetClipboard(text string) {
+	selectionText = text
+	ssoc := xproto.SetSelectionOwnerChecked(w.conn, w.win.Id, clipboardAtom, xproto.TimeCurrentTime)
+	err := ssoc.Check()
+	if err != nil {
+		fmt.Println(err)
+	}
+}
+
+func (w *Window) getSelection(selAtom xproto.Atom) string {
+	csc := xproto.ConvertSelectionChecked(w.conn, w.win.Id, selAtom, textAtom, selAtom, xproto.TimeCurrentTime)
+	err := csc.Check()
+	if err != nil {
+		fmt.Println(err)
+		return ""
+	}
+
+	select {
+	case r := <- w.selnotify:
+		if !r {
+			return ""
+		}
+		gpc := xproto.GetProperty(w.conn, true, w.win.Id, selAtom, textAtom, 0, 5 * 1024 * 1024)
+		gpr, err := gpc.Reply()
+		if err != nil {
+			fmt.Println(err)
+			return ""
+		}
+		/*typename, _ := xprop.AtomName(w.xu, gpr.Type)
+		println("Type", typename)*/
+		if gpr.BytesAfter != 0 {
+			fmt.Println("Clipboard too large")
+			return ""
+		}
+		return string(gpr.Value[:gpr.ValueLen])
+	case <- time.After(1 * time.Second):
+		fmt.Println("Clipboard retrieval failed, timeout")
+		return ""
+	}
+}
+
+func (w *Window) GetClipboard() string {
+	return w.getSelection(clipboardAtom)
+}
+
+func (w *Window) GetPrimarySelection() string {
+	return w.getSelection(primaryAtom)
+}
