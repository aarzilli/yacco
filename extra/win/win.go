package main

import (
	"os"
	"os/signal"
	"log"
	"strings"
	"bufio"
	"io"
	"io/ioutil"
	"os/exec"
	"fmt"
	"time"
	"syscall"
	"strconv"
	"github.com/kr/pty"
	"code.google.com/p/go9p/p"
	"yacco/util"
)

var debug = false

func read(fd *os.File) string {
	b := make([]byte, 1024)
	n, err := fd.Read(b)
	util.Allergic(debug, err)
	return string(b[:n])
}

const (
	ANSI_NORMAL = iota
	ANSI_0D
	ANSI_ESCAPE
)

func updateDir(cmd *exec.Cmd, ctlfd io.Writer) {
	dest, err := os.Readlink(fmt.Sprintf("/proc/%d/cwd", cmd.Process.Pid))
	if err != nil {
		return
	}
	ctlfd.Write([]byte(fmt.Sprintf("name %s/+Win\n", dest)))
}

func outputReader(cmd *exec.Cmd, stdout io.Reader, bodyfd io.Writer, outbufid string, ctlfd io.Writer, addrfd io.Writer, xdatafd io.Writer, outputReaderDone chan struct{}) {
	bufout := bufio.NewReader(stdout)
	bufbody := bufio.NewWriter(bodyfd)
	escseq := []byte{}
	state := ANSI_NORMAL
	for {
		if bufout.Buffered() == 0 {
			if debug {
				log.Println("flushing1")
			}
			bufbody.Flush()
			updateDir(cmd, ctlfd)
		}
		ch, err := bufout.ReadByte()
		if err != nil {
			if debug {
				fmt.Println("Exit output reader with error: " + err.Error())
			}
			bufbody.Flush()
			close(outputReaderDone)
			return
		}

		switch state {
		case ANSI_NORMAL:
			switch ch {
			case 0x0d:
				state = ANSI_0D
			case 0x08:
				bufbody.Flush()
				_, err = addrfd.Write([]byte("-#1"))
				util.Allergic(debug, err)
				xdatafd.Write([]byte{ 0 })
			case 0x1b:
				escseq = []byte{}
				state = ANSI_ESCAPE
			default:
				util.Allergic(debug, bufbody.WriteByte(ch))
				if ch == '\n' {
					if debug {
						log.Println("flushing2")
					}
					bufbody.Flush()
					//updateDir(cmd, ctlfd)
				}
			}
		case ANSI_ESCAPE:
			escseq = append(escseq, ch)
			if (len(escseq) > 1) && (ch >= 0x40) && (ch <= 0x7e) {
				state = ANSI_NORMAL
				switch escseq[len(escseq)-1] {
				case 'J':
					if debug {
						fmt.Println("Requesting screen clear")
					}
					bufbody.Flush()
					_, err = addrfd.Write([]byte(","))
					util.Allergic(debug, err)
					xdatafd.Write([]byte{ 0 })
				case 'H':
					if debug {
						fmt.Println("Requesting back to home")
					}
					bufbody.Flush()
					// XXX Clears a race with the processing of the event generated by the flush -- very wonky
					time.Sleep(500 * time.Millisecond)
					addr := readAddr(outbufid)
					_, err = addrfd.Write([]byte("#0"))
					util.Allergic(debug, err)
					ctlfd.Write([]byte("dot=addr\n"))
					util.Allergic(debug, err)
					fmt.Fprintf(addrfd, "#%d,#%d", addr[0], addr[1])
				}
			}

		case ANSI_0D:
			state = ANSI_NORMAL
			switch ch {
			case 0x0a:
				util.Allergic(debug, bufbody.WriteByte(ch))
				bufbody.Flush()
			default:
				if debug {
					fmt.Println("Requesting line delete")
				}
				bufbody.Flush()
				_, err = addrfd.Write([]byte("-+"))
				util.Allergic(debug, err)
				xdatafd.Write([]byte{ 0 })
				util.Allergic(debug, bufbody.WriteByte(ch))
			}
		}
	}

	if debug {
		fmt.Println("output reader finished")
	}

	bufbody.Flush()
}

func readAddr(outbufid string) []int {
	addrfd, err := os.Open(os.ExpandEnv("$yd/" + outbufid + "/addr"))
	util.Allergic(debug, err)
	defer addrfd.Close()
	str := read(addrfd)
	v := strings.Split(str, ",")
	iv := []int{ 0, 0 }
	iv[0], err = strconv.Atoi(v[0])
	util.Allergic(debug, err)
	iv[1], err = strconv.Atoi(v[1])
	util.Allergic(debug, err)
	return iv
}

func readXdata(outbufid string) string {
	xdatafd, err := os.Open(os.ExpandEnv("$yd/" + outbufid + "/xdata"))
	util.Allergic(debug, err)
	defer xdatafd.Close()
	xdata, err := ioutil.ReadAll(xdatafd)
	util.Allergic(debug, err)
	return string(xdata)
}

func eventReader(eventfd io.ReadWriter, ctlfd io.ReadWriter, addrfd io.Writer, bodyfd io.ReadWriter, pty io.Writer, outbufid string) {
	buf := make([]byte, 1024)
	addrfd.Write([]byte("$"))
	for {
		if debug {
			log.Println("Waiting for event")
		}
		n, err := eventfd.Read(buf)
		if err == io.EOF {
			break
		}
		util.Allergic(debug, err)
		if n < 2 {
			log.Fatalf("Not enough read from event file")
		}

		event := string(buf[:n])

		origin := event[0]
		etype := event[1]
		v := strings.SplitN(event[2:], " ",  5)
		if len(v) != 5 {
			log.Fatalf("Wrong number of arguments from split: %d", len(v))
		}

		s, err:= strconv.Atoi(v[0])
		util.Allergic(debug, err)
		_, err = strconv.Atoi(v[1])
		util.Allergic(debug, err)
		flags, err := strconv.Atoi(v[2])
		util.Allergic(debug, err)
		arglen, err := strconv.Atoi(v[3])
		util.Allergic(debug, err)

		arg := v[4]

		for len(arg) < arglen {
			n, err := eventfd.Read(buf)
			util.Allergic(debug, err)
			arg += string(buf[:n])
			event += string(buf[:n])
		}

		if arg[len(arg)-1] == '\n' {
			arg = arg[:len(arg)-1]
		}

		if (debug) {
			fmt.Printf("event <%s>\n", event)
		}

		switch etype {
		case 'x', 'X':
			if flags != 0 {
				_, err := eventfd.Write([]byte(event))
				util.Allergic(debug, err)
			} else {
				switch arg {
				case "Term":
					//TODO: send sigterm
				default:
					bodyfd.Write([]byte(arg))
					bodyfd.Write([]byte{ '\n' })
					pty.Write([]byte(arg))
					pty.Write([]byte{ '\n' })
				}
			}

			util.Allergic(debug, err)
		case 'l', 'L':
			_, err := eventfd.Write([]byte(event))
			util.Allergic(debug, err)

		case 'I':
			if (origin == 'E') || (origin == 'F') {
				if debug {
					fmt.Println("Moving address forward")
				}
				_, err = addrfd.Write([]byte("$"))
				util.Allergic(debug, err)
				_, err = ctlfd.Write([]byte("dot=addr\n"))
				util.Allergic(debug, err)
			} else {
				addr := readAddr(outbufid)
				if (addr[0] <= s) && (len(arg) > 0) && (arg[len(arg)-1] == '\n') {
					if debug {
						fmt.Printf("From to: %d $\n", addr[0])
					}
					fmt.Fprintf(addrfd, "#%d,$", addr[0])
					command := readXdata(outbufid)
					if debug {
						fmt.Printf("Sending: %s", command)
					}
					pty.Write([]byte(command))
				} else {
					if debug {
						if addr[0] > s {
							fmt.Printf("Before input address %d %d\n", addr[0], s)
						} else {
							fmt.Printf("Not terminted by newline\n")
						}
					}
				}
			}
		}
	}
}

func run(c *exec.Cmd) *os.File {
	pty, tty, err := pty.Open()
	util.Allergic(debug, err)
	defer tty.Close()

	termios, err := TcGetAttr(tty)
	util.Allergic(debug, err)
	termios.SetIFlags(ICRNL|IUTF8)
	termios.SetOFlags(ONLRET)
	termios.SetCFlags(CS8|CREAD)
	termios.SetLFlags(ICANON)
	termios.SetSpeed(38400)
	err = TcSetAttr(tty, TCSANOW, termios)
	util.Allergic(debug, err)
	err = TcSetAttr(pty, TCSANOW, termios)

	c.Stdout = tty
	c.Stdin = tty
	c.Stderr = tty
	c.SysProcAttr = &syscall.SysProcAttr{Setctty: true, Setsid: true}
	err = c.Start()
	if err != nil {
		pty.Close()
		util.Allergic(debug, err)
	}
	return pty
}

func notifyProc(notifyChan <-chan os.Signal, endChan <-chan bool, bodyfd io.ReadWriter, ctlfd io.ReadWriter, eventfd io.Closer) {
	if debug {
		fmt.Println("Waiting for signal")
	}
	select {
	case <- notifyChan:
	case <- endChan:
	}
	if debug {
		fmt.Println("Ending")
	}
	bodyfd.Write([]byte("~\n"))
	ctlfd.Write([]byte("dump\n"))
	ctlfd.Write([]byte("dumpdir\n"))
	eventfd.Close()
	os.Exit(0)
}

func easyCommand(cmd string) bool {

	for _, c := range cmd {
		switch c {
		case '#', ';', '&', '|', '^', '$', '=', '\'', '`', '{', '}', '(', ')', '<', '>', '[', ']', '*', '?', '~':
			return false
		}
	}
	return true
}

func main() {
	p9clnt, err := util.YaccoConnect()
	util.Allergic(debug, err)

	outbufid, ctlfd, eventfd, err := util.FindWin("Win", p9clnt)
	util.Allergic(debug, err)

	bodyfd, err := p9clnt.FOpen("/" + outbufid + "/body", p.OWRITE)
	util.Allergic(debug, err)
	addrfd, err := p9clnt.FOpen("/" + outbufid + "/addr", p.OWRITE)
	util.Allergic(debug, err)
	xdatafd, err := p9clnt.FOpen("/" + outbufid + "/xdata", p.OWRITE)
	util.Allergic(debug, err)

	_, err = ctlfd.Write([]byte("name +Win"))
	util.Allergic(debug, err)

	_, err = ctlfd.Write([]byte("dump " + strings.Join(os.Args, " ") + "\n"))
	util.Allergic(debug, err)
	wd, _ := os.Getwd()
	_, err = ctlfd.Write([]byte("dumpdir " + wd + "\n"))

	util.SetTag(p9clnt, outbufid, "Jobs Kill Delete Term ")

	_, err = addrfd.Write([]byte(","))
	util.Allergic(debug, err)
	xdatafd.Write([]byte{ 0 })

	var cmd *exec.Cmd
	if len(os.Args) > 1 {
		cmdstr := strings.Join(os.Args[1:], " ")
		if easyCommand(cmdstr) {
			vcmdstr := strings.Split(cmdstr, " ")
			cmd = exec.Command(vcmdstr[0], vcmdstr[1:]...)
		} else {
			cmd = exec.Command("/bin/sh", "-c",  cmdstr)
		}
	} else {
		shell := os.Getenv("yaccoshell")
		if shell == "" {
			shell = os.Getenv("SHELL")
		}
		if shell == "" {
			shell = "/bin/bash"
		}

		cmd = exec.Command(shell)
	}

	os.Setenv("TERM", "ansi")
	os.Setenv("PAGER", "")
	os.Setenv("EDITOR", "")
	os.Setenv("VISUAL", "")

	pty := run(cmd)

	outputReaderDone := make(chan struct{})
	go eventReader(eventfd, ctlfd, addrfd, bodyfd, pty, outbufid)
	go outputReader(cmd, pty, bodyfd, outbufid, ctlfd, addrfd, xdatafd, outputReaderDone)

	if debug {
		fmt.Println("Waiting for command to finish")
	}

	notifyChan := make(chan os.Signal)
	endChan := make(chan bool)
	signal.Notify(notifyChan, os.Interrupt, os.Kill)
	go notifyProc(notifyChan, endChan, bodyfd, ctlfd, eventfd)

	cmd.Wait()

	<- outputReaderDone

	endChan <- true
	if debug {
		log.Printf("Finished")
	}
	time.Sleep(1 * time.Second)
	eventfd.Close()
	os.Exit(0)
}
